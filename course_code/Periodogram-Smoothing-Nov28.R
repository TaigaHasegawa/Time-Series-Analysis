## armaspec.s

armaspec=function(T=5000,arcoeff,macoeff,vare){

## Input
## T = resolution in frequency (length of time series)
## arcoeff = vector of coefficients of the AR component of the time series
## macoeff = vector of coefficients of the MA component
## vare = variance of the white noise error

## Output 
## specout = spectrum of the ARMA process defined from (0, pi]

## Note: This is the parameterization of the ARMA(p,q) process 
## that I will adopt in this program 
## X(t) = arcoeff[1]X(t-1) + ... + arcoeff[p]X(t-p) + 
## W(t) + macoeff[1]W(t-1) + ... + macoeff[q]W(t-q)
## I will assume that the process is already causal and 
## invertible, i.e., the user has done these checks before
## attempting to derive the spectrum.

freq = 2*pi*seq(0, T-1)/T;

arcoeff = c(1, -arcoeff);
macoeff = c(1, macoeff);

theta=c(1:T); phi=c(1:T);

for (k in 1:(T)){

theta.temp=0;
for (m in 1: (length(macoeff)))
{
theta.temp = theta.temp + macoeff[m]*complex(mod=1, arg=-1*m*freq[k])}
theta[k] = (abs(theta.temp))^2

phi.temp=0;
for (m in 1: (length(arcoeff))){
phi.temp = phi.temp + arcoeff[m]*complex(mod=1, arg=-1*m*freq[k])}
phi[k] = (abs(phi.temp))^2

}

spec = vare*(theta)/(phi)
specout = spec[2:(T/2 + 1)]
return(specout)
}

##################
#show the peridogram
###########################
 data("soi")
 par(mfrow=c(2,1))
 plot(soi,type="l")
 
 soi.per = spec.pgram(soi, log="no")
 which.max(soi.ave$spec)/soi.ave$n.used
 1/(which.max(soi.ave$spec)/soi.ave$n.used)
 soi.per$spec[40] # soi pgram at freq 1/12 = 40/480
 soi.per$spec[10] # soi pgram at freq 1/48 = 10/480

?spec.pgram

#########################################################
#spec.pgram automatically remove the linear trend. 
#########################################################
soi.per2<-spec.pgram(soi+2, taper=0, log="no")
soi.per3<-spec.pgram(soi+2+(1:length(soi)),taper=0, log="no")
sum((soi.per$spec-soi.per2$spec)^2)
sum((soi.per$spec-soi.per3$spec)^2)

soi.per4<-spec.pgram(soi+2, taper=0, log="Yes")

#############################################################
#check and see soi.per2 and soi.per3 produce the same results
#############################################################



#####################
#note that $m$ is twice the number in c(*,*)
#show the modified daniell kernel
par(mfrow=c(2,2))
plot(kernel("modified.daniell",c(1,1)))
plot(kernel("modified.daniell",c(2,2)))
plot(kernel("modified.daniell",c(4,4)))
plot(kernel("modified.daniell",c(7,7)))

#################
#plot the weights generated by daniell kernel
##############################################3
par(mfrow=c(2,2))
plot(kernel("daniell",1))
plot(kernel("daniell",2))
plot(kernel("daniell",3))
plot(kernel("daniell",4))

kernel("daniell",1)
kernel("daniell",c(1,1))
kernel("daniell",2)
kernel("daniell",c(2,2))

kernel("modified.daniell",1)
kernel("modified.daniell",c(1,1))
kernel("modified.daniell",2)
kernel("modified.daniell",c(2,2))

####################
Example 4.10
 par(mfrow=c(2,1))
 k = kernel("daniell",4)
 ?kernel
 soi.ave = spec.pgram(soi, k, taper=0, log="no")
 abline(v=1/12, lty="dotted")
# abline(v=2/12, lty="dotted")
# abline(v=3/12, lty="dotted")
 abline(v=1/48, lty="dotted")
 soi.ave 
#find the dominant frequency
#and the corresponding period 

#dominant frequency
which.max(soi.ave$spec)/soi.ave$n.used
#corresponding period
1/(which.max(soi.ave$spec)/soi.ave$n.used)


 df = soi.ave$df   
 U = qchisq(.025,df) 
 L = qchisq(.975,df) 
 soi.ave$spec[10]    
 soi.ave$spec[40]   
# -- intervals --
 df*soi.ave$spec[10]/L # 0.334547
 df*soi.ave$spec[10]/U # 1.336000
 df*soi.ave$spec[40]/L # 0.8044755
 df*soi.ave$spec[40]/U # 3.212641
#


####################################
#Estimating the spectrum of a simulated series
###############################################
set.seed(100)
T<-500
datasimu<-arima.sim(n=T,list(ar=c(sqrt(2)/2,-1/4)))
par(mfrow=c(2,2))
plot(datasimu,type="l")
acf(datasimu,lag.max=50)
pacf(datasimu)
#obtain periodogram at fourier frequencies
freq<-(1:(T/2))/T
per<-(abs(fft(datasimu)))^2/T
per<-per[2:(T/2+1)]
#frequency \omega_j, j=1,\cdots,T/2
?armaspec
truespec<-armaspec(T, arcoeff=c(sqrt(2)/2,-1/4), macoeff=c(0), vare=1);
Umax<-max(max(truespec),max(per))
par(mfrow=c(2,2))
#periodogram with true spectrum
plot(freq,per,type="o",ylab="spectral density",ylim=c(0,Umax))
lines(freq,truespec,ylim=c(0,Umax),col=2,lwd=3)
#smoothed periodogram with true spectrum
k1 = kernel("modified.daniell", c(1,1))
per.ave1 = spec.pgram (datasimu, kernel =k1, taper=0, log ="no",plot=F)$spec
plot(freq,per,type="o",ylab="spectral density",ylim=c(0,Umax))
lines(freq,truespec,ylim=c(0,Umax),col=2,lwd=3)
lines(freq,per.ave1,ylim=c(0,Umax),col=3,lwd=3)
#smoothed periodogram with a different bandwidth
k2 = kernel("modified.daniell", c(3,3))
per.ave2 = spec.pgram(datasimu, kernel=k2, taper=0, log="no",plot=F)$spec
plot(freq,per,type="o",ylab="spectral density",ylim=c(0,Umax))
lines(freq,truespec,ylim=c(0,Umax),col=2,lwd=3)
lines(freq,per.ave2,ylim=c(0,Umax),col=4,lwd=3)
#smoothed periodogram with a different bandwidth
k3 = kernel("modified.daniell", c(7,7))
per.ave3 = spec.pgram(datasimu, kernel=k3, taper=0, log="no",plot=F)$spec
plot(freq,per,type="o",ylab="spectral density",ylim=c(0,Umax))
lines(freq,truespec,ylim=c(0,Umax),col=2,lwd=3)
lines(freq,per.ave3,ylim=c(0,Umax),col=5,lwd=3)


###########################
#parametric estimation
###########################
#simulation example
###########
sim.ar = ar(datasimu, method="mle",order.max=10)   # obtain AICs
 plot(0:10, sim.ar$aic, type="l") # plot AICs
 sim.ar            
paraspec<-armaspec(T, arcoeff=c(0.6259,-0.2364), macoeff=c(0), vare=1.02);

Umax=max(c(per,truespec,paraspec))
plot(freq,per,type="o",ylim=c(0,Umax))
lines(freq,truespec,ylim=c(0,Umax),col=2,lwd=3)
lines(freq,paraspec,ylim=c(0,Umax),col=3,lwd=3)


###############################3
#Real data example: soi data
#############################33

 par(mfrow=c(2,1))
 k = kernel("modified.daniell",c(2,2))
 soi.ave = spec.pgram(soi, k, taper=0, log="no")
 abline(v=1/12, lty="dotted")

 soi.arspec<-spec.ar(soi, n.freq=nextn(length(soi))/2+1, log="no")           

#number of Fourier frequencies from 0 to 1/2, including 0 and 1/2
#to make comparison with smoothed peridogram easy, we should use
#n.freq=nextn(length(soi))/2+1. Note that the default for n.freq is 500

 nn<-nextn(length(soi))
 freq<-(1:(nn/2))/nn
 soi.arspec
Umax<-max(c(soi.arspec$spec,soi.ave$spec))
plot(freq,soi.ave$spec,type="o",ylab="spectral density",ylim=c(0,Umax))
lines(freq,soi.arspec$spec[2:(nn/2+1)],ylim=c(0,Umax),col=3,lwd=3)

 abline(v=1/12, lty="dotted")     # locate yearly period
 soi.ar = ar(soi, order.max=30)   # obtain AICs
 plot(0:30, soi.ar$aic, type="l") # plot AICs
 soi.ar                           # view results


##################
#spectrum command
##############
?spectrum
spec1<-spectrum(datasimu,taper=0,span=c(4,4),log="no")
spec1

######################
#Multiple time series
########################
data<-cbind(soi,rec)
plot(data)
acf(data)
sr = mvspec(cbind(soi,rec), kernel("daniell",9), plot.type="coh", plot=FALSE)
sr$df                     # df = 35.8625
f = qf(.999, 2, sr$df-2)  # f = 8.529792
C = f/(18+f)              # C = 0.3188779
plot(sr, plot.type = "coh", ci.lty = 2)
abline(h = C)
              # df = 35.8625
f2 = qf(.95, 2, sr$df-2)  # 
C2 = f2/(18+f2)              # 
abline(h=C2)


plot(sr,plot.type="marginal")

plot(sr,plot.type="phase")

